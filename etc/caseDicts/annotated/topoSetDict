/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  dev
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      topoSetDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

actions
(
    // Example:pick up internal faces on outside of cellSet
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Load initial cellSet
    {
        action  new;
        type    cellSet;
        name    c0;
        source  labelToCell;
        sourceInfo
        {
            value (12 13 56);
        }
    }

    // Get all faces in cellSet
    {
        action  new;
        type    faceSet;
        name    f0;
        source  cellToFace;
        sourceInfo
        {
            set     c0;
            option  all;
        }
    }

    // Determine inverse cellSet
    {
        action  new;
        type    cellSet;
        name    c1;
        source  cellToCell;
        sourceInfo
        {
            set c0;
        }
    }
    {
        name    c1;
        type    cellSet;
        action  invert;
    }

    // Keep in f0 all faces in c1
    {
        name    f0;
        type    faceSet;
        action  subset;
        source  cellToFace;
        sourceInfo
        {
            set     c1;
            option  all;
        }
    }


    // Example: create cellZone from geometric region
    {
        action  new;
        type    cellZoneSet;
        name    c0;
        source  boxToCell;
        sourceInfo
        {
            box   (0.04 0 0)(0.06 100 100);
        }
    }
);

/*
// List of actions. Each action is a dictionary with e.g.

// action to perform on set.
action  new;

// - require no source : clear/invert/remove
//       clear  : clears set or zone
//       invert : select all currently non-selected elements
//       remove : removes set or zone
// - require source    : new/add/delete/subset
//       new    : create new set or zone from source
//       add    : add source to contents
//       delete : deletes source from contents
//       subset : keeps elements both in contents and source

// name of set
name    c0;

// type: pointSet/faceSet/cellSet/faceZoneSet/cellZoneSet
type    cellSet;

// source: method to generate the set

// cellSet from cell labels
source labelToCell;
sourceInfo
{
    value (12 13 56);   // labels of cells
}

// copy of a cellSet
source cellToCell;
sourceInfo
{
    set c1;
}

// cellSet from cell zone
source zoneToCell;
sourceInfo
{
    name ".*Zone";      // Name of cellZone, regular expressions allowed
}

// cellSet from cells on master or slave side of faceZone
source faceZoneToCell;
sourceInfo
{
    name ".*Zone";      // Name of faceZone, regular expressions allowed
    option master;      // master/slave
}

// cellSet from faceSet
source faceToCell;
sourceInfo
{
    set f0;             // Name of faceSet

    // option neighbour; // cell with neighbour in faceSet
    // option owner;     //  ,,       owner
    option any;         // cell with any face in faceSet
    // option all;       // cell with all faces in faceSet
}

// cellSet from pointSet
source pointToCell;
sourceInfo
{
    set p0;
    option any;         // cell with any point in pointSet
    // option edge;      // cell with an edge with both points in pointSet
}

// cellSet baed on shape of cells
source shapeToCell;
sourceInfo
{
    type hex;           // hex/wedge/prism/pyr/tet/tetWedge/splitHex
}

// cellSet inside a rectangular bounding box or boxes
source boxToCell;
sourceInfo
{
    box   (0 0 0) (1 1 1);
    // boxes   ((0 0 0) (1 1 1) (10 10 10)(11 11 11));
}

// cellSet inside rotated box
source rotatedBoxToCell;
sourceInfo
{
    origin   (0.2 0.2 -10);
    i        (0.2 0.2 0);
    j        (-0.2 0.2 0);
    k        (10 10 10);
}

// cellSet within a cylinder
source cylinderToCell;
sourceInfo
{
    point1   (0.2 0.2 -10); // start point on cylinder axis
    point2   (0.2 0.2 0);   // end point on cylinder axis
    radius   5.0;
}

// cellSet within a sphere
source sphereToCell;
sourceInfo
{
    centre   (0.2 0.2 -10);
    radius   5.0;
}

// cellSet nearest to point locations
source nearestToCell;
sourceInfo
{
    points ((0 0 0) (1 1 1)(2 2 2));
}

// Select based on surface
source surfaceToCell;
sourceInfo
{
    file            "surface.stl";
    useSurfaceOrientation false;     // use closed surface inside/outside
                                     // test (ignores includeCut,
                                     // outsidePoints)
    outsidePoints   ((-99 -99 -59)); // definition of outside
    includeCut      false;           // cells cut by surface
    includeInside   false;           // cells not on outside of surf
    includeOutside  false;           // cells on outside of surf
    nearDistance    -1;              // cells with centre near surf
                                     // (set to -1 if not used)
    curvature       0.9;             // cells within nearDistance
                                     // and near surf curvature
                                     // (set to -100 if not used)
}

// cellSet by field values within a range
source fieldToCell;
sourceInfo
{
    fieldName   U;      // Note: uses mag(U) since volVectorField
    min         0.1;
    max         0.5;
}

// cellSet based on a mesh region (non-face connected part of (subset of)mesh)
source regionToCell;
sourceInfo
{
    set         c0;         // optional name of cellSet giving mesh subset
    insidePoints ((1 2 3)); // points inside region to select
    nErode      0;          // optional number of layers to erode
                            // selection
}

// cellSet based on a total volume beneath a plane with specified normal
source targetVolumeToCell;
sourceInfo
{
    volume  2e-05;
    normal  (0 1 0);          // usually in direction of gravity
}

// copy of a faceSet
source faceToFace;
sourceInfo
{
    set f1;
}

// faceSet from a cellSet
source cellToFace;
sourceInfo
{
    set c0;
    option all;         // All faces of cells
    // option both;      // Only faces whose owner&neighbour are in cellSet
}

// faceSet from a pointSet
source pointToFace;
sourceInfo
{
    set p0;
    option any;         // Faces using any point in pointSet
    // option all        // Faces with all points in pointSet
    // option edge       // Faces with two consecutive points in pointSet
}

// faceSet specified by labels
source labelToFace;
sourceInfo
{
    value (12 13 56);   // labels of faces
}

// faceSet from patches
source patchToFace;
sourceInfo
{
    name ".*Wall";      // Name of patch or patch group,
                        // (regular expressions allowed)
}

// faceSet from the boundary
source boundaryToFace;
sourceInfo
{
}

// faceSet from a faceZone
source zoneToFace;
sourceInfo
{
    name ".*Zone1";     // Name of faceZone, regular expressions allowed
}

// faceSet inside a rectangular bounding box or boxes
source boxToFace;
sourceInfo
{
    box  (0 0 0) (1 1 1);
   // boxes   ((0 0 0) (1 1 1) (10 10 10)(11 11 11));
}

// faceSet with normal orientation within a tolerance
source normalToFace;
sourceInfo
{
    normal (0 0 1);     // Vector
    cos     0.01;       // Tolerance (max cos of angle)
}

// faceSet from existing faceSet, nearest to given position
source  regionToFace;
sourceInfo
{
    set         f0;
    nearPoint   (0.1 0.1 0.005);
}

// copy a pointSet
source pointToPoint;
sourceInfo
{
    set p1;
}

// pointSet from a cellSet
source cellToPoint;
sourceInfo
{
    set c0;
    option all;         // all points of cell
}

// pointSet from a faceSet
source faceToPoint;
sourceInfo
{
    set f0;             // name of faceSet
    option all;         // all points of face
}

// pointSet specified by labels
source labelToPoint;
sourceInfo
{
    value (12 13 56);   // labels of points
}

// pointSet from pointZone
source zoneToPoint;
sourceInfo
{
    name ".*Zone";      // name of pointZone, regular expressions allowed
}

// pointSet nearest to positions
source nearestToPoint;
sourceInfo
{
   points ((0 0 0) (1 1 1));
}

// pointSet inside a rectangular bounding box or boxes
source boxToPoint;
sourceInfo
{
   box   (0 0 0) (1 1 1);
   // boxes   ((0 0 0) (1 1 1) (10 10 10)(11 11 11));
}

// pointSet, based on surface
source surfaceToPoint;
sourceInfo
{
    file            "surface.stl";
    nearDistance    0.1;    // points near to surface
    includeInside   false;  // points on inside of surface
                            // (requires closed surface with consistent
                            //  normals)
    includeOutside  false;  //   ,,    outside  ,,
}

// pointSet based on distance to a patch or patches
source patchDistanceToCell;
sourceInfo
{
    patch     ".*Wall";                   // Patch name
    // patches   (".*Wall" atmosphere);   // List of patch names
    distance  0.1;                        // Distance below which to
                                          // include cells
}

// cellZoneSet reads cellZone and writes both cellZone and cellSet
// cellZone can be generated from existing cellSet by
source setToCellZone;
sourceInfo
{
    set c0;           // name of cellSet
}

// faceZoneSet manipulates both cellZone and cellSet
// faceZone can be generated from existing faceSet by
source setToFaceZone;
sourceInfo
{
    faceSet f0;       // name of faceSet
}

// faceZone from faceSet, using cellSet to determine orientation
source setsToFaceZone;
sourceInfo
{
    faceSet f0;       // name of faceSet
    cellSet c0;       // name of cellSet of slave side
    flip    false;    // optional: flip the faceZone (so now the cellSet
                      //           is the master side)
}

//faceZone from surface with orientation from normals on surface
source  searchableSurfaceToFaceZone;
sourceInfo
{
    surface searchableSphere;
    centre  (0.05 0.05 0.005);
    radius  0.025;
    // name  sphere.stl; // Optional name if surface triSurfaceMesh
}

// faceZone from a plane
source  planeToFaceZone;
sourceInfo
{
    point   (0 0 4);
    normal  (1 0 0.2);
    include all;          // Take all faces (default)
    // include closest;   // Take the closest contiguous region of
                          // faces to the plane point
}

// pointZoneSet manipulates both cellZone and cellSet
// pointZone can be generated from existing pointSet by
source setToPointZone;
sourceInfo
{
    set p0;           // name of pointSet
}
*/


 ************************************************************************* //
